# 虚拟机类加载机制
虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接会使用的Java类型，这就是虚拟机的类加载机制。

与那些在编译时需要进行连接工作的语言不通，在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性，Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。

类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。其中验证、准备、解析3个部分统称为连接。

## JVM预定义的三种类型类加载器
启动（Bootstrap）类加载器：是用本地代码实现的类装入器，它负责将\<Java\_Runtime\_Home\>/lib下面的类库加载到内存中（比如rt.jar）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。

标准扩展（Extension）类加载器：是由Sun的ExtClassLoader实现的。它负责将\<Java\_Runtime\_Home\>/lib/ext或者由系统变量java.ext.dir指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。

系统（System）类加载器：是由Sun的AppClassLoader实现的。它负责将系统类路径（CLASSPATH）中指定的类库加载到内存中。开发者可以直接使用系统类加载器。

## ClassLoader工作机制
事实上，ClassLoader除了能将Class加载到JVM中之外，还有一个重要的作用就是审查每个类应该由谁加载，它是一种父优先的等级加载机制。最后，它还负责将Class字节码重新解析成JVM统一要求的对象格式。

ClassLoader是个抽象类，它还有很多子类，我们如果要实现自己的ClassLoader，一般都会继承URLClassLoader这个子类，因为这个类已经帮我们实现了大部分工作。

## 双亲委派机制
如何理解双亲委派机制？某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。

委托机制的意义：防止内存中出现多份同样的字节码。

如何实现自定义ClassLoader？有什么用？
