# RabbitMQ基础知识
## 消费者和生产者
生产者（producer）创建消息，然后发布（发送）到代理服务器（rabbitmq）。什么是消息呢？消息包含两部分内容：有效载荷（payload）和标签（label）。有效载荷就是你想要传输的数据。标签描述了有效载荷，并且rabbitmq用它来决定谁将获得消息的拷贝。举例来说，不同于TCP协议的是，当你明确指定发送方和接收方时，AMQP只会用标签表述这条消息（一个交换器的名称和可选的主题标记），然后把消息交给rabbit。rabbit会根据标签把消息发送给感兴趣的接收方。这种通信方式是一种“发后即忘”（fire-and-forget）的单向方式。

它们连接到代理服务器上，并订阅到队列（queue）上。把消息队列想象成一个具名邮箱。每当消息到达特定的邮箱时，rabbitmq会将其发送给其中一个订阅的/监听的消费者。当消费者接收到消息时，它只得到消息的一部分：有效载荷。在消息路由过程中，消息的标签并没有随有效载荷一同传递。rabbitmq甚至不会告诉你是谁生产/发送了消息。就好比你拿起信件时，却发现所有的信封都是空白的。同理，如果需要明确知道是谁生产的AMQP消息的话，就要看生产者是否把发送方信息放入有效载荷中。

什么是信道呢？你必须首先连接到rabbit，才能消费或者发布消息。你在应用程序和rabbit代理服务器之间创建一条TCP连接。一旦TCP连接打开（你通过了认证），应用程序就可以创建一条AMQP信道。信道是建立在“真实的”TCP连接内的虚拟连接。

AMQP命令都是通过信道发送出去的。每条信道都会被指派一个唯一ID（AMQP库会帮你记住ID的）。无论是发布消息、订阅队列或是接收消息，这些动作都是通过信道完成的。你也许会问为什么我们需要信道呢？为什么不直接通过TCP连接发送AMQP命令呢？主要原因在于对操作系统来说建立和销毁TCP会话是非常昂贵的开销。假设应用程序从队列消费消息，并根据服务需求合理调度线程。假设你只进行TCP连接。这不仅造成TCP连接的巨大浪费，并且操作系统每秒也就只能建立这点数量的连接。因此，你可能很快就碰到性能瓶颈了。如果我们为所有线程只使用一条TCP连接以满足性能方面的要求，但又能确保每个线程的私密性，就像拥有独立连接一样的话，那不就非常完美吗？

这就是要引入信道概念的原因。线程启动后，会在现成的连接上创建一条信道，也就获得了连接到rabbit上的私密通信路径，而不会给操作系统的TCP栈造成额外负担。因此，你可以每秒成百上千次地创建信道而不会影响操作系统。在一条TCP连接上创建多少条信道是没有限制的。

重要的是记住消费者和生产者是消息发送和消息接收概念的体现，而非客户端和服务端。从总体上来说，消息通信，特别是AMQP，可以被当作加强版的传输层。使用信道，你能够根据应用需要，尽可能多地创建并行的传输层，而不会被TCP连接约束所限制。当你理解了这些概念时，你就能把rabbitmq看作软件的路由器了。

## 从底部开始构造：队列
从概念上来讲，AMQP消息路由必须有三部分：交换器、队列和绑定。生产者把消息发布到交换器上；消息最终到达队列，并被消费者接收；绑定决定了消息如何从路由器路由到特定的队列。

当rabbit队列拥有多个消费者时，队列收到的消息将以循环（round-robin）的方式发送给消费者。每条消息只会发送给一个订阅的消费者。

消费者接收到的每一条消息都必须进行确认。消费者必须通过AMQP的basic.ack命令显式地向rabbitmq发送一个确认，或者在订阅到队列的时候就将auto\_ack参数设置为true。当设置了auto\_ack时，一旦消费者接收消息，rabbitmq会自动视其确认了消息。需要记住的是，消费者对消息的确认和告诉生产者消息已经被接收了这两件事毫不相关。因此，消费者通过确认命令告诉rabbitmq它已经正确地接收了消息，同时rabbitmq才能安全地把消息从队列中删除。

如果消费者收到一条消息，然后确认之前从rabbit断开连接（或者从队列上取消订阅），rabbitmq会认为这条消息没有分发，然后重新分发给下一个订阅的消费者。如果你的应用程序崩溃了，这样做可以确保消息会被发送给另一个消费者进行处理。另一方面，如果应用程序有bug而忘记确认消息的话，rabbit将不会给该消费者发送更多消息了。这是因为在上一条消息被确认之前，rabbit会认为这个消费者并没有准备好接收下一条消息。你可以好好利用这一点。如果处理消息内容非常耗时，则你的应用程序可以延迟确认该消息，直到消息处理完成。这样可以防止rabbit持续不断的消息涌向你的应用而导致过载。

## 如何明确拒绝消息
只要消息消息尚未确认，则你有以下两个选择：

（1）把消费者从rabbitmq服务器断开连接。这会导致rabbitmq自动重新把消息入队并发送给另一个消费者。这样做的好处是所有的rabbitmq版本都支持。缺点是，这样连接/断开连接的方式会额外增加rabbitmq的负担（如果消费者在处理每条消息时都遇到错误的话，会导致潜在的重大负荷）。

（2）如果你正使用rabbitmq2.0.0或更新的版本，那就使用AMQP的basic.reject命令。顾名思义：basic.reject允许消费者拒绝rabbitmq发送的消息。如果把reject命令的requeue参数设置成true的话，rabbitmq立即会把消息重新发送给下一个订阅的消费者。如果设置成false的话，rabbitmq立即会把消息从队列中移除，而不会把它发送给新的消费者。你也可以通过对消息确认的方式来简单地忽略该消息（这种忽略消息的方式的优势在于所有版本的rabbitmq都支持）。如果你检测到一条格式错误的消息而任何一个消费者都无法处理的时候，这样做就十分有用。

## 如何创建队列
消费者和生产者都能使用AMQP的queue.declare命令来创建队列。但是如果消费者在同一条信道上订阅了另一个队列的话，就无法再声明队列了。必须首先取消订阅，将信道置为“传输”模式。当创建队列时，你常常想要指定队列名称。消费者订阅队列时需要队列名称，并在创建绑定时也需要指定队列名称。如果不指定队列名称的话，rabbit会分配一个随机名称并在queue.declare命令的相应中返回。

对负载均衡来说，队列是绝佳方案。只需附加一堆消费者，并让rabbitmq以循环的方式均匀地分配发来的消息。

## 交换器和绑定
当你想要将消息投递到队列时，你通过把消息发送给交换器来完成。然后，根据确定的规则，rabbitmq将会决定消息该投递到哪个队列。这些规则被称作路由键（routing key）。队列通过路由键绑定到交换器。当你把消息发送到代理服务器时，消息将拥有一个路由键——即便是空的——rabbitmq也会将其和绑定使用的路由键进行匹配。如果相匹配的话，那么消息将会投递到该队列。如果路由的消息不匹配任何绑定模式的话，消息将进入“黑洞”。

除了可以用交换器和绑定来完成不同的使用场景之外，还有另一个好处是：对于发送消息给服务器的发布者来说，它不需要关心服务器的另一端（整个消息处理环节中的队列和消费者）的逻辑。

协议中定义的常用的不同类型交换器有3种：direct、fanout、topic。

direct交换器非常简单：如果路由键匹配的话，消息就被投递到对应的队列。服务器必须实现direct类型交换器，包含一个空白字符串名称的默认交换器。当声明一个队列时，它会自动绑定到默认交换器，并以队列名称作为路由键。

fanout交换器会将收到的消息广播到绑定的队列上。消息通信模式很简单：当你发送一条消息到fanout交换器时，它会把消息投递给所有附加在此交换器上的队列。这允许你对单条消息做不同方式的反应。如果你使用的fanout交换器，你唯一需要做的就是为新的消费者写一段代码，然后声明新的队列并将其绑定到fanout交换器上。就如同我们之前讲的那样，发送方的代码和消费者的代码两者之间完全解耦了，这允许你轻而易举地添加应用程序的功能。

Topic交换器允许你实现有趣的消息通信场景，它使得来自不同源头的消息能够到达同一个队列。（这个交换器没弄懂）

## 总结回顾
- AMQP架构中最关键的几个组件分别是交换器、队列和绑定
- 根据绑定规则将队列绑定到交换器上
- 消息是发布到交换器上的
- 有三种类型的交换器：direct、fanout和topic
- 基于消息的路由键和交换器类型，服务器会决定将消息投递到哪个队列去


