# 高并发原则
## 1.无状态
如果涉及的应用是无状态的，那么应用比较容易进行水平扩展。实际生产环境可能是这样的：应用无状态，配置文件有状态。

## 2.拆分
在系统设计初期，是做一个大而全的系统还是按功能模块拆分系统，这个需要根据环境进行权衡。
- 系统维度：按照系统功能/业务拆分，例如商品系统、购物车、结算等系统。
- 功能维度：对一个系统进行功能再拆分，比如，优惠券系统可以拆分为后台券创建系统、领券系统、用券系统等。
- 读写维度：根据读写笔录特征进行拆分。比如商品系统，交易的各个系统都会读取数据，读的量大于写，因此可以拆分成商品写服务、商品读服务；度服务可以考虑使用缓存提升性能；写的量太大时，需要考虑分库分表。

## 3.服务化
首先，判断是不是只需要简单的单点远程服务调用，单机不行集群是不是可以解决？在客户端注册多台机器并使用Nginx进行负载均衡是不是就可以解决？之后还可以考虑使用服务自动注册和发现（如Dubbo使用ZooKeeper）。

进程内服务——单机远程服务——集群手动注册服务——自动注册和发现服务——服务的分组/隔离/路由——服务治理如限流/黑白名单。

## 4.消息队列
消息队列是用来解耦一些不需要同步调用的服务或者订阅一些自己系统关心的变化。使用消息队列可以实现服务解耦（一对多消费）、异步处理、流量削峰/缓冲等。比如，电商系统中的交易订单数据，该数据有非常多的系统关心并订阅，比如，订单生产系统、定期送系统、订单风控系统等等。如果订阅者太多，那么订阅单个消息队列就会成为瓶颈，此时，需要考虑对消息队列进行多个镜像复制。

使用消息队列时，还要注意处理生产消息失败，以及消息重复接收时的场景。有些消息队列产品会提供生产重试功能，在达到指定重试次数还未生产成功时，会对外通知生产失败。这时，对于不能容忍失败的业务场景来说，一定要做好后续的数据处理工作，如持久化数据要同时增加日志、报警等。对于消息重复问题，特别是一些分布式消息队列，出于对性能的开销的考虑，在一些场景下会发生消息重复接收，需要在业务层面进行防重处理。

大流量缓冲：牺牲强一致性，保证最终一致性即可。

数据校对：定期扫描原始表，通过对业务数据进行校对，有问题的要进行补偿，扫描周期根据实际场景进行定义。

## 5.缓存银弹
客户端：浏览器缓存、客户端应用缓存；

客户端网络：代理服务器开启缓存；

广域网：使用代理服务器（含CDN）；使用镜像服务器；使用P2P技术；

源站及源站网络：使用接入层提供的缓存机制、应用层、分布式缓存、静态化和伪静态化、使用服务器操作系统提供的缓存机制。

浏览器缓存。设置请求的过期时间，如对响应头Expires、Cache-control进行控制。这种机制适用于对实时性不太敏感的数据，如商品详情页框架、商家评分等；但对于价格、库存等实时要求比较高的数据，就不能做浏览器端缓存。

APP客户端缓存。在大促之前把APP需要访问的一些素材提前缓存到APP客户端。

CDN缓存。一般有两种机制：推送机制（当内容变更后主动推送到CDN边缘节点）和拉取机制（先访问边缘节点，当没有内容时，回源到源服务器拿到内容并存储到节点上），两种方式各有利弊。

接入层缓存。对于没有CDN缓存的应用来说，可以考虑使用如Nginx搭建一层接入层，该接入层可以考虑使用如下机制实现。
- URL重写：将URL按照指定的顺序或者格式重写，去除随机数。
- 一致性哈希：按照指定的参数（如分类/商品编号）做一致性Hash，从而保证相同数据落到同一台服务器上。
- proxy\_cache：使用内存级/SSD级代理缓存来缓存内容。
- proxy\_cache\_lock：使用lock机制，将多个回源合并为一个，以减少回源量，并设置相应的lock超时时间。
- shared\_dict：如果架构使用了Nginx+lua实现，则可以考虑使用lua shared\_dict进行cache，最大的好处就是reload缓存不会丢失。

应用层缓存。我们使用Tomcat时，可以使用堆内缓存/堆外缓存，堆内缓存的最大问题就是重启时内存中的缓存会丢失，此时流量风暴来临，则有可能冲垮应用；还可考虑使用local redis cache来代替堆外内存；或在接入层使用shared\_dict来将缓存前置，以减少风暴。local redis cache，通过在应用所在服务器上部署一组redis，应用直接读本机redis获取数据，多机之间使用主从机制同步数据。这种方式没有网络消耗，性能是最优的。
