# 索引相关知识点
## 关于索引失效的情形总结如下
	    请求表上的数据行超出表总记录数30%，变成全表扫描
	    谓词上的索引列上存在NULL值
	    谓词上的索引列条件使用函数
	    谓词上的索引列条件进行了相关运算
	    谓词上的索引列条件上使用了<>，NOT IN操作符
	    复合索引中，第一个索引列使用范围查询--只能用到部份或无法使用索引
	    复合索引中，第一个查询条件不是最左索引列
	    模糊查询条件列最左以通配符%开始
	    内存表（HEAP表）使用HASH索引时，使用范围检索或者ORDER BY
	    表关联字段类型不一样（包括某些长度不一样，但像varchar(10)与char(10)则可以，MYSQL经过内部优化处理）
 
## 索引类型（按用途非严格划分）
	    普通索引，这是最基本的索引，无任何限制
	    唯一索引，与普通索引类似，索引列值必须唯一，允许NULL值
	    全文索引，基于词干方式创建索引，多用于BLOB数据类型
	    单列索引，仅基于一列创建的索引
	    多列索引，基于多列创建的索引，列顺序非常重要
	    空间索引，用作地理数据存储
	    主键索引，是一种特殊的唯一索引，不允许有NULL值，通常在建表时创建。
## 索引的优缺点
#### 索引的优点
	    大大减少了服务器需要扫描的数据量
	    可以帮助服务器避免排序或减少使用临时表排序
	    索引可以随机I/O变为顺序I/O

#### 索引的缺点
	    需要占用磁盘空间，因此冗余低效的索引将占用大量的磁盘空间
	    降低DML性能，对于数据的任意增删改都需要调整对应的索引，甚至出现索引分裂
	    索引会产生相应的碎片，产生维护开销
## 单列索引和组合索引的区别
当我们执行查询的时候，MySQL只能使用一个索引。如果你有三个单列的MySQL数据库索引，MySQL会试图选择一个限制最严格的索引。

但是，即使是限制最严格的单列索引，它的限制能力也肯定远远低于firstname、lastname、age这三个列上的多列索引。
## 最左前缀原则
通过实例理解单列索引、多列索引以及最左前缀原则
实例：现在我们想查出满足以下条件的用户id：   
mysql\>SELECT ｀uid｀ FROM people WHERE lname｀=’Liu’ AND ｀fname｀=’Zhiqun’ AND ｀age｀=26   
因为我们不想扫描整表，故考虑用索引。
#### 单列索引： 
ALTER TABLE people ADD INDEX lname (lname); 
  
将lname列建索引，这样就把范围限制在lname=’Liu’的结果集1上，之后扫描结果集1，产生满足fname=’Zhiqun’的结果集2，再扫描结果集2，找到 age=26的结果集3，即最终结果。

由于建立了lname列的索引，与执行表的完全扫描相比，效率提高了很多，但我们要求扫描的记录数量仍旧远远超过了实际所需 要的。虽然我们可以删除lname列上的索引，再创建fname或者age 列的索引，但是，不论在哪个列上创建索引搜索效率仍旧相似。
#### 多列索引： 
ALTER TABLE people ADD INDEX lname\_fname\_age (lame,fname,age); 
  
为了提高搜索效率，我们需要考虑运用多列索引,由于索引文件以B－Tree格式保存，所以我们不用扫描任何记录，即可得到最终结果。

注：在mysql中执行查询时，只能使用一个索引，如果我们在lname,fname,age上分别建索引,执行查询时，只能使用一个索引，mysql会选择一个最严格(获得结果集记录数最少)的索引。

#### 最左前缀：
顾名思义，就是最左优先，上例中我们创建了lname \_fname \_age多列索引,相当于创建了(lname)单列索引，(lname,fname)组合索引以及(lname,fname,age)组合索引。

注：在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。

索引是因为B+树结构 所以查找快 如果单看第三列是非排序的。   
多列索引是先按照第一列进行排序，然后在第一列排好序的基础上再对第二列排序，如果没有第一列的话，直接访问第二列，那第二列肯定是无序的，直接访问后面的列就用不到索引了。 
  
所以如果不是在前面列的基础上而是但看后面某一列，索引是失效的。